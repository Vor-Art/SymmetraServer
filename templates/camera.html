<!doctype html>
<html>
<head>
    <title>Photo Manager</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="d-flex justify-content-between align-items-center my-3">
            <h1>Photo Manager</h1>
            <button class="btn btn-danger" onclick="window.location.href='/logout'">Logout</button>
        </div>
        <hr>

        <!-- Session Information and Controls -->
        <div class="my-3">
            <h3>Current Session: {{ session_name }}</h3>
            <form action="/new_session" method="post" class="form-inline d-inline-flex align-items-center">
                <input type="text" name="session_name" class="form-control mr-2" placeholder="Session Name">
                <button type="submit" class="btn btn-primary">New Session</button>
            </form>
            <!-- Updated Process Session Button and Progress Bar -->
            <button id="process-session-button" class="btn btn-primary ml-2">Process Session</button>

            <form action="/observe_the_models" method="post" class="d-inline-block ml-2">
                <button type="submit" class="btn btn-primary">Proceed to the models</button>
            </form>
            
            <div id="upload-progress" class="progress ml-2" style="display:none; width: 200px;">
                <div id="upload-progress-bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
        </div>

        <!-- Camera Selection and Session Controls -->
        <div class="row">
            <!-- Video Display Column -->
            <div class="col-md-6">
                <div id="video-container" class="mb-3">
                    <video id="video" width="100%" autoplay playsinline></video>
                </div>
            </div>

            <!-- Controls Column -->
            <div class="col-md-6">
                <!-- Camera Selection and Quality Settings -->
                <div class="camera-controls">
                    <h4>Select Camera and Quality</h4>
                    <label for="cameraSelect">Choose Camera:</label>
                    <select id="cameraSelect" class="form-control">
                        <option value="">Loading cameras...</option>
                    </select>

                    <label for="qualitySelect" class="mt-2">Choose Quality:</label>
                    <select id="qualitySelect" class="form-control">
                        <option value="">Select a camera first</option>
                    </select>

                    <button id="startCameraButton" class="btn btn-success btn-block mt-3">Start Camera</button>
                    <button id="stopCameraButton" class="btn btn-danger btn-block mt-2" disabled>Stop Camera</button>
                </div>

                <hr>

                <!-- Session Controls -->
                <div id="session-controls" class="mb-3">
                    <h4>Session Controls</h4>
                    <label for="interval">Capture every N milliseconds:</label>
                    <input type="number" id="interval" value="1000" min="100" step="100" class="form-control">

                    <div class="button-container position-relative my-2">
                        <button id="start-session" class="btn btn-success btn-block position-absolute w-100 large-button" style="top: 0; left: 0;">Start Session</button>
                        <button id="pause-session" class="btn btn-danger btn-block position-absolute w-100 large-button" style="top: 0; left: 0; display: none;">Pause Session</button>
                    </div>
                </div>

                <!-- Upload Photos from Local Machine -->
                <form action="/upload_photo" method="post" enctype="multipart/form-data" class="mb-3">
                    <div class="custom-file">
                        <input type="file" name="files[]" accept="image/*" multiple class="custom-file-input" id="fileUpload" required>
                        <label class="custom-file-label" for="fileUpload">Choose photos to upload</label>
                    </div>
                    <button type="submit" class="btn btn-secondary btn-block mt-2">Upload Photos</button>
                </form>
            </div>
        </div>

        <!-- Current Session Photos -->
        <div class="session-photos mb-5">
            <h2>Current Session Photos</h2>
            <form id="current-session-form" action="" method="post">
                <div class="photo-grid">
                    {% for filename in current_photos %}
                    <div class="photo-wrapper" data-filename="{{ filename }}">
                        <img src="{{ url_for('uploaded_file', username=session['username'], session_name=session_name, filename=filename) }}" alt="Photo">
                        <input type="checkbox" name="selected_photos[]" value="{{ filename }}" class="photo-checkbox">
                    </div>
                    {% endfor %}
                </div>
                <button type="button" class="btn btn-info mt-3" onclick="downloadSelectedPhotos('{{ session_name }}')">Download Selected Photos</button>
            </form>
        </div>

        <!-- Hidden canvas for capturing photos -->
        <canvas id="canvas" style="display:none;"></canvas>
    </div>

    <!-- Include Bootstrap JS and dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

    <script>
        // Camera Selection and Quality Variables
        const cameraSelect = document.getElementById('cameraSelect');
        const qualitySelect = document.getElementById('qualitySelect');
        const startCameraButton = document.getElementById('startCameraButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const video = document.getElementById('video');
        let currentStream = null;

        // Common resolutions
        const resolutions = [
            { label: '480p', width: 640, height: 480 },
            { label: '720p', width: 1280, height: 720 },
            { label: '1080p', width: 1920, height: 1080 },
            { label: '2k', width: 2048, height: 1080 },
            { label: '4K', width: 3840, height: 2160 }
        ];

        // Initialize the application
        async function initCameraSelection() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                await getCameras();
            } catch (err) {
                alert('Camera access is required to use this application.');
                cameraSelect.innerHTML = '<option value="">Camera access denied</option>';
                qualitySelect.innerHTML = '<option value="">Cannot select quality without camera access</option>';
            }
        }

        // Populate camera list
        async function getCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });

                if (videoDevices.length === 0) {
                    cameraSelect.innerHTML = '<option value="">No cameras found</option>';
                } else {
                    cameraSelect.selectedIndex = 0;
                    populateQualitySelect(videoDevices[0].deviceId);
                }
            } catch (err) {
                cameraSelect.innerHTML = '<option value="">Error accessing cameras</option>';
            }
        }

        // Populate quality list based on selected camera
        cameraSelect.addEventListener('change', () => {
            const selectedCamera = cameraSelect.value;
            if (!selectedCamera) {
                qualitySelect.innerHTML = '<option value="">Select a camera first</option>';
                return;
            }
            populateQualitySelect(selectedCamera);
        });

        // Function to populate quality select
        function populateQualitySelect(selectedCamera) {
            qualitySelect.innerHTML = '';
            resolutions.forEach(res => {
                const option = document.createElement('option');
                option.value = JSON.stringify({ width: res.width, height: res.height });
                option.text = res.label;
                qualitySelect.appendChild(option);
            });
        }

        // Start Camera with selected settings
        startCameraButton.addEventListener('click', async () => {
            if (currentStream) stopStream();

            const selectedCamera = cameraSelect.value;
            const selectedQuality = qualitySelect.value;
            if (!selectedCamera) {
                alert('Please select a camera.');
                return;
            }

            let constraints = { video: { deviceId: { exact: selectedCamera } } };
            if (selectedQuality) {
                const quality = JSON.parse(selectedQuality);
                constraints.video.width = { exact: quality.width };
                constraints.video.height = { exact: quality.height };
                setCanvasDimensions(quality.width, quality.height);
            }

            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                stopCameraButton.disabled = false;
                startCameraButton.disabled = true;
            } catch (err) {
                alert('Could not access the camera with the selected settings.');
            }
        });

        // Stop the Camera
        stopCameraButton.addEventListener('click', stopStream);

        function stopStream() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                currentStream = null;
                stopCameraButton.disabled = true;
                startCameraButton.disabled = false;
            }
        }

        // Refresh camera list when devices change
        navigator.mediaDevices.addEventListener('devicechange', getCameras);

        // Canvas for capturing photos
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        // Set canvas dimensions based on selected quality
        function setCanvasDimensions(width, height) {
            canvas.width = height;
            canvas.height = width;
        }

        // Start photo capture session
        const startSessionBtn = document.getElementById('start-session');
        const pauseSessionBtn = document.getElementById('pause-session');
        let autoCaptureInterval = null;
        let capturedPhotos = [];

        startSessionBtn.addEventListener('click', () => {
            startAutoCapture();
            toggleSessionButtons(true);
        });

        pauseSessionBtn.addEventListener('click', () => {
            stopAutoCapture();
            toggleSessionButtons(false);
        });

        function toggleSessionButtons(isSessionStarted) {
            startSessionBtn.style.display = isSessionStarted ? 'none' : 'block';
            pauseSessionBtn.style.display = isSessionStarted ? 'block' : 'none';
        }

        function startAutoCapture() {
            const intervalInput = document.getElementById('interval');
            const interval = parseInt(intervalInput.value);
            if (isNaN(interval) || interval < 100) {
                alert('Please enter a valid interval (minimum 100 milliseconds).');
                return;
            }
            autoCaptureInterval = setInterval(capturePhoto, interval);
        }

        function stopAutoCapture() {
            clearInterval(autoCaptureInterval);
        }

        function capturePhoto() {
            if (!currentStream) {
                alert('Camera is not started. Please start the camera first.');
                stopAutoCapture();
                toggleSessionButtons(false);
                return;
            }

            // Capture the current video frame to canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataURL = canvas.toDataURL('image/png');

            // Display the photo in the container
            const img = document.createElement('img');
            img.src = dataURL;
            img.alt = 'Photo';

            const photoWrapper = document.createElement('div');
            photoWrapper.classList.add('photo-wrapper');
            photoWrapper.dataset.filename = '';
            photoWrapper.appendChild(img);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'selected_photos[]';
            checkbox.classList.add('photo-checkbox');
            photoWrapper.appendChild(checkbox);

            const photoGrid = document.querySelector('.session-photos .photo-grid');
            photoGrid.insertBefore(photoWrapper, photoGrid.firstChild);

            // Store the image data in the capturedPhotos array
            capturedPhotos.push(dataURL);
        }

        // Process Session Button Event Listener
        document.getElementById('process-session-button').addEventListener('click', function(event) {
            event.preventDefault();
            if (capturedPhotos.length === 0) {
                alert('No photos to send.');
                return;
            }

            // Send the photos to the server
            sendPhotos();
        });

        function sendPhotos() {
            const processButton = document.getElementById('process-session-button');
            processButton.disabled = true;

            const formData = new FormData();
            capturedPhotos.forEach((dataURL, index) => {
                // Convert dataURL to Blob
                const blob = dataURLToBlob(dataURL);
                formData.append('files[]', blob, `photo_${index}.png`);
            });

            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    updateProgressBar(percentComplete);
                } else {
                    // Unable to compute progress, show indeterminate progress bar
                    updateProgressBar();
                }
            });

            xhr.onload = function() {
                processButton.disabled = false;
                resetProgressBar();

                if (xhr.status === 200) {
                    alert('Photos uploaded successfully.');
                    capturedPhotos = [];
                    location.reload();
                } else {
                    alert('An error occurred while uploading the photos.');
                }
            };

            xhr.onerror = function() {
                processButton.disabled = false;
                resetProgressBar();
                alert('An error occurred while uploading the photos.');
            };

            xhr.open('POST', '/upload_photo');
            xhr.send(formData);
        }

        function dataURLToBlob(dataURL) {
            const parts = dataURL.split(';base64,');
            const contentType = parts[0].split(':')[1];
            const raw = window.atob(parts[1]);
            const rawLength = raw.length;

            const uInt8Array = new Uint8Array(rawLength);

            for (let i = 0; i < rawLength; ++i) {
                uInt8Array[i] = raw.charCodeAt(i);
            }

            return new Blob([uInt8Array], { type: contentType });
        }

        function updateProgressBar(percent) {
            const progressBar = document.getElementById('upload-progress-bar');
            const progressContainer = document.getElementById('upload-progress');
            progressContainer.style.display = 'block';

            if (percent !== undefined) {
                progressBar.style.width = percent + '%';
                progressBar.innerHTML = Math.floor(percent) + '%';
                progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
            } else {
                // Indeterminate progress bar
                progressBar.style.width = '100%';
                progressBar.innerHTML = 'Uploading...';
                progressBar.classList.add('progress-bar-striped', 'progress-bar-animated');
            }
        }

        function resetProgressBar() {
            const progressBar = document.getElementById('upload-progress-bar');
            const progressContainer = document.getElementById('upload-progress');
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
            progressBar.innerHTML = '';
            progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
        }

        // Initialize camera selection on page load
        window.onload = () => {
            initCameraSelection();
        };

        // File upload label update
        $('#fileUpload').on('change', function() {
            const fileName = $(this).val().split('\\').pop();
            $(this).next('.custom-file-label').html(fileName || 'Choose photos to upload');
        });

        // Download selected photos
        function downloadSelectedPhotos(sessionName) {
            const form = event.target.closest('form');
            const selectedPhotos = Array.from(form.querySelectorAll('.photo-checkbox:checked')).map(cb => cb.value);
            if (selectedPhotos.length === 0) {
                alert('Please select at least one photo.');
                return;
            }
            const formData = new FormData();
            selectedPhotos.forEach(photo => formData.append('selected_photos[]', photo));
            formData.append('session_name', sessionName);
            fetch('/download_photos', { method: 'POST', body: formData })
                .then(response => response.blob())
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${sessionName}_photos.zip`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                })
                .catch(error => { console.error('Error:', error); });
        }
    </script>
</body>
</html>
