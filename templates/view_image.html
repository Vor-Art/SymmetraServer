<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer with Optimized Surface Distance Calculation</title>
    <style>
        body { margin: 0; position: relative; }
        canvas { display: block; }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: #fff;
            text-decoration: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .distance-info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 5px;
            display: none;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px;
            background-color: #333;
            color: #fff;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .controls label {
            margin-right: 5px;
        }
        .controls input, .controls select {
            padding: 5px;
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: #fff;
            margin-right: 10px;
        }
        .controls button {
            padding: 5px 10px;
            background-color: #ff4444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <a href="/view_results" class="back-button">Back to Library</a>
    <div class="distance-info" id="distanceInfo">Distance: 0</div>
    <div class="controls">
        <label for="mode">Select Mode:</label>
        <select id="mode">
            <option value="e">Euclidean Distance</option>
            <option value="p">Path Distance</option>
            <option value="a">Angle Measurement</option>
            <option value="s">Surface Distance</option>
        </select>
        <label for="scale">Scale (units to cm):</label>
        <input type="number" id="scale" value="0" step="0.1" min="0.1" />
        <label for="sphereSize">Sphere Size:</label>
        <input type="number" id="sphereSize" value="0" step="0.005" min="0.001" />
        <label for="segmentSize">Segment Size:</label>
        <input type="number" id="segmentSize" value="0" step="0.005" min="0.001" />
        <button id="resetButton">Reset</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, raycaster, mouse;
        let points = [];
        let spheres = [];
        let lines = [];
        let model;
        let vertexMap = new Map(); // Map for storing vertex indices and positions
        let sampledVertices = []; // Array for sampled vertices for efficient pathfinding
        let neighborsMap = new Map(); // Map for storing precomputed neighbors
        let mode = 'e'; // Default mode is Euclidean Distance
        let scale = 22; // Default scale factor for cm conversion
        let sphereSize = 0.01; // Default sphere size
        let segmentSize = 1; // Default segment size
        const distanceInfo = document.getElementById('distanceInfo');
        const scaleInput = document.getElementById('scale');
        const sphereSizeInput = document.getElementById('sphereSize');
        const segmentSizeInput = document.getElementById('segmentSize');
        const resetButton = document.getElementById('resetButton');

        scaleInput.value = scale;
        sphereSizeInput.value = sphereSize;
        segmentSizeInput.value = segmentSize;


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-0.58, 0.26, 0.60);
            camera.lookAt(0.21, -0.00, 0.70);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 0).normalize();
            scene.add(directionalLight);

            const loader = new THREE.OBJLoader();
            loader.load(
                `/models/{{ username }}/{{ model_name }}/model.obj`,
                function (obj) {
                    obj.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material.transparent = true;
                            child.material.opacity = 0.7; // Set transparency level here
                        }
                    });
                    model = obj;
                    scene.add(model);
                    preprocessModel(); // Preprocess model to reduce computation
                },
                undefined,
                function (error) {
                    console.error('An error happened loading the model:', error);
                }
            );

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableRotate = true;
            controls.minDistance = 0;
            controls.maxDistance = 7;
            controls.target.set(0.21, -0.00, 0.70);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onClick, false);
            document.getElementById('mode').addEventListener('change', (event) => {
                mode = event.target.value;
                resetScene(); // Reset scene for new mode
            });
            scaleInput.addEventListener('change', () => scale = parseFloat(scaleInput.value));
            sphereSizeInput.addEventListener('change', () => sphereSize = parseFloat(sphereSizeInput.value));
            segmentSizeInput.addEventListener('change', () => segmentSize = parseFloat(segmentSizeInput.value));
            resetButton.addEventListener('click', resetScene);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onClick(event) {
            // Update mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Set raycaster from camera and mouse
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray, excluding lines
            const intersects = raycaster.intersectObjects([model], true);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                if (mode === 'e') {
                    // Euclidean Distance Mode
                    if (points.length < 1) {
                        addPointAndSphere(point);
                    } else if (points.length === 1) {
                        addPointAndSphere(point);
                        const distance = points[0].distanceTo(points[1]) * scale;
                        displayDistance(`Euclidean Distance: ${distance.toFixed(2)} cm`);
                        drawSegment(points[0], points[1]);
                    } else if (points.length === 2){
                        resetScene();
                        addPointAndSphere(point);
                    } 
                } else if (mode === 'p') {
                    // Path Distance Mode
                    addPointAndSphere(point);
                    if (points.length > 1) {
                        drawPath();
                        const totalDistance = calculatePathDistance() * scale;
                        displayDistance(`Path Euclidean Distance: ${totalDistance.toFixed(2)} cm`);
                    }
                } else if (mode === 'a') {
                    // Angle Measurement Mode
                    if (points.length < 2) {
                        addPointAndSphere(point);
                    } else if (points.length === 2) {
                        addPointAndSphere(point);
                        const angle = calculateAngle(points[0], points[1], points[2]);
                        displayDistance(`Angle: ${angle.toFixed(2)} degrees`);
                        drawSegment(points[0], points[1]);
                        drawSegment(points[1], points[2]);
                    } else {
                        resetScene();
                        addPointAndSphere(point);
                    }
                } else if (mode === 's' && points.length < 2) {
                    // Surface Distance Mode
                    addPointAndSphere(point);
                    if (points.length === 2) {
                        calculateSurfaceDistance(points[0], points[1]);
                    }
                }
            }
        }

        function addPointAndSphere(point) {
            points.push(point);
            const sphere = createSphere(point);
            scene.add(sphere);
            spheres.push(sphere);
        }

        function createSphere(position) {
            const geometry = new THREE.SphereGeometry(sphereSize, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(position);
            return sphere;
        }

        function removeSpheres() {
            spheres.forEach(sphere => scene.remove(sphere));
            spheres = [];
        }

        function removeLines() {
            lines.forEach(line => scene.remove(line));
            lines = [];
        }

        function resetScene() {
            points = [];
            removeSpheres();
            removeLines();
            distanceInfo.style.display = 'none';
        }

        function drawPath() {
            removeLines(); // Clear previous lines
            for (let i = 0; i < points.length - 1; i++) {
                drawSegment(points[i], points[i + 1]);
            }
        }

        function drawSegment(start, end) {
            const material = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: segmentSize });
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            lines.push(line);
        }

        function calculatePathDistance() {
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += points[i].distanceTo(points[i + 1]);
            }
            return totalDistance;
        }

        function calculateAngle(p1, p2, p3) {
            const v1 = p1.clone().sub(p2);
            const v2 = p3.clone().sub(p2);
            const angle = v1.angleTo(v2);
            return THREE.MathUtils.radToDeg(angle); // Convert to degrees
        }

        function displayDistance(message) {
            distanceInfo.style.display = 'block';
            distanceInfo.textContent = message;
        }

        function preprocessModel() {
            // Adjustable parameters
            const samplingStep = 1000; // Sample every 1000th vertex (adjust for performance)
            const neighborThreshold = 0.2; // Distance threshold for neighbors (adjust based on model size)
            const maxNeighbors = 5; // Limit the number of neighbors to avoid too many connections

            console.log(`Starting model preprocessing with samplingStep: ${samplingStep}, neighborThreshold: ${neighborThreshold}, maxNeighbors: ${maxNeighbors}`);

            model.traverse(child => {
                if (child.isMesh) {
                    console.log(`Processing mesh: ${child.name}`);
                    const vertices = child.geometry.attributes.position.array;
                    // Sample vertices with a step size to reduce computation
                    for (let i = 0; i < vertices.length; i += 3 * samplingStep) {
                        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
                        sampledVertices.push(vertex);
                        vertexMap.set(sampledVertices.length - 1, vertex);
                    }
                    console.log(`Sampled ${sampledVertices.length} vertices from mesh: ${child.name}`);
                }
            });

            console.log(`Total sampled vertices: ${sampledVertices.length}`);

            // Precompute neighbors for sampled vertices
            sampledVertices.forEach((vertex, index) => {
                const neighbors = getVertexNeighbors(vertex, index, neighborThreshold, maxNeighbors);
                neighborsMap.set(index, neighbors);
                console.log(`Vertex ${index}: found ${neighbors.length} neighbors, neighbors: ${neighbors}`);
            });

            console.log('Neighbors precomputed for all sampled vertices');
        }

        // Optimized function to get neighbors of a vertex based on proximity in sampled vertices
        function getVertexNeighbors(vertex, currentIndex, threshold, maxNeighbors) {
            console.log(`Finding neighbors for vertex ${currentIndex} with threshold ${threshold} and maxNeighbors ${maxNeighbors}`);
            const neighbors = [];
            sampledVertices.forEach((otherVertex, index) => {
                if (index !== currentIndex) { // Exclude the vertex itself
                    const distance = vertex.distanceTo(otherVertex);
                    if (distance < threshold) {
                        neighbors.push(index);
                        if (neighbors.length >= maxNeighbors) {
                            console.log(`Max neighbors reached for vertex ${currentIndex}`);
                            return neighbors; // Limit the number of neighbors
                        }
                    }
                }
            });
            console.log(`Vertex ${currentIndex}: total neighbors found = ${neighbors.length}`);
            return neighbors;
        }

        // New function to calculate surface distance using a pathfinding algorithm
        function calculateSurfaceDistance(start, end) {
            console.log(`Calculating surface distance from start ${start.toArray()} to end ${end.toArray()}`);
            // Find closest sampled vertices on the model
            const startIdx = findClosestSampledVertex(start);
            const endIdx = findClosestSampledVertex(end);

            console.log(`Closest vertex to start: ${startIdx}, closest vertex to end: ${endIdx}`);

            // Calculate path between the closest vertices
            const path = aStarPathfinding(startIdx, endIdx);
            if (path.length > 0) {
                console.log(`Path found with ${path.length} vertices`);
                // Get path points in 3D space and draw them
                const pathPoints = path.map(index => vertexMap.get(index));
                drawSurfacePath(pathPoints);

                // Calculate total path distance
                let surfaceDistance = 0;
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    surfaceDistance += pathPoints[i].distanceTo(pathPoints[i + 1]);
                }
                displayDistance(`Surface Distance: ${(surfaceDistance * scale).toFixed(2)} cm`);
                console.log(`Total surface distance: ${(surfaceDistance * scale).toFixed(2)} cm`);
            } else {
                console.log('No path found between the two points.');
            }
        }

        // Function to draw the calculated surface path
        function drawSurfacePath(pathPoints) {
            console.log(`Drawing surface path with ${pathPoints.length} points`);
            removeLines(); // Remove previous paths
            for (let i = 0; i < pathPoints.length - 1; i++) {
                drawSegment(pathPoints[i], pathPoints[i + 1]);
                console.log(`Drawing segment from ${pathPoints[i].toArray()} to ${pathPoints[i + 1].toArray()}`);
            }
        }

        // Find the closest sampled vertex index to a given point
        function findClosestSampledVertex(point) {
            console.log(`Finding closest sampled vertex to point ${point.toArray()}`);
            let closestIndex = -1;
            let closestDistance = Infinity;
            sampledVertices.forEach((vertex, index) => {
                const distance = point.distanceTo(vertex);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestIndex = index;
                }
            });
            console.log(`Closest vertex index: ${closestIndex}, distance: ${closestDistance}`);
            return closestIndex;
        }

        // A* Pathfinding algorithm optimized for sampled vertices
        function aStarPathfinding(startIdx, endIdx) {
            console.log(`Starting A* pathfinding from ${startIdx} to ${endIdx}`);
            const openSet = new Set([startIdx]);
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            gScore.set(startIdx, 0);
            fScore.set(startIdx, heuristicCostEstimate(startIdx, endIdx));

            while (openSet.size > 0) {
                let current = getLowestScoreNode(openSet, fScore);

                if (current === endIdx) {
                    console.log(`Reached end vertex: ${endIdx}`);
                    return reconstructPath(cameFrom, current);
                }

                openSet.delete(current);
                console.log(`Processing vertex ${current}, neighbors: ${neighborsMap.get(current)}`);

                const neighbors = neighborsMap.get(current);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore.get(current) + vertexMap.get(current).distanceTo(vertexMap.get(neighbor));
                    
                    // Check for cycles before updating cameFrom
                    if (cameFrom.has(neighbor) && cameFrom.get(neighbor) === current) {
                        console.log(`Skipping update for vertex ${neighbor} to avoid cycle with ${current}`);
                        continue;
                    }
                    
                    if (tentativeGScore < (gScore.get(neighbor) || Infinity)) {
                        console.log(`Updating vertex ${neighbor}: came from ${current}, tentativeGScore = ${tentativeGScore}`);
                        cameFrom.set(neighbor, current);
                        gScore.set(neighbor, tentativeGScore);
                        fScore.set(neighbor, tentativeGScore + heuristicCostEstimate(neighbor, endIdx));
                        openSet.add(neighbor);
                    }
                }
            }

            console.log('No path found');
            return []; // No path found
        }

        // Reconstruct the path from the cameFrom map
        function reconstructPath(cameFrom, current) {
            console.log(`Reconstructing path starting from vertex ${current}`);
            const totalPath = [current];
            const visitedNodes = new Set(); // Keep track of visited nodes

            while (cameFrom.has(current)) {
                if (visitedNodes.has(current)) { // Cycle detected
                    console.log(`Cycle detected at vertex ${current}. Breaking the loop.`);
                    break;
                }

                visitedNodes.add(current);
                current = cameFrom.get(current);
                totalPath.unshift(current);
                console.log(`Step back to vertex ${current}`);
            }

            console.log(`Path reconstructed: ${totalPath}`);
            return totalPath;
        }

        // Get the node with the lowest score in fScore map
        function getLowestScoreNode(set, fScore) {
            let lowestNode = null;
            let lowestScore = Infinity;
            set.forEach(node => {
                const score = fScore.get(node);
                if (score < lowestScore) {
                    lowestScore = score;
                    lowestNode = node;
                }
            });
            console.log(`Lowest score node: ${lowestNode}, score: ${lowestScore}`);
            return lowestNode;
        }

        // Heuristic function for A* pathfinding (Euclidean distance)
        function heuristicCostEstimate(startIdx, endIdx) {
            const distance = vertexMap.get(startIdx).distanceTo(vertexMap.get(endIdx));
            console.log(`Heuristic cost estimate from ${startIdx} to ${endIdx}: ${distance}`);
            return distance;
        }




        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize the scene
        init();
    </script>
</body>
</html>
